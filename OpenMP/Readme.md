## Sidenote: Preprocessor Directives
We now give a brief descriptions of directives in C/C++. For reference, see: [cplusplus.com/doc/tutorial/preprocessor/](https://cplusplus.com/doc/tutorial/preprocessor/)
### What are Preprocessor Directives?
Preprocessor directives are lines included in the code of programs preceded by a hash sign (`#`). These lines are not program statements but directives for the _preprocessor_. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.
### General Syntax
These _preprocessor directives_ extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is ends. No semicolon (`;`) is expected at the end of a preprocessor directive. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash (`\`).
### Types of Directives (C++)
- **Macro definitions** (`#define`, `#undef`)
	- General syntax: `#define identifier replacement`, `#undef identifier`
	- When the preprocessor encounters this directive, it replaces any occurrence of `identifier` in the rest of the code by `replacement`. This `replacement` can be an expression, a statement, a block or simply anything.
	- Defined macros are not affected by block structure. A macro lasts until it is undefined with the `#undef` preprocessor directive.
	- `#define` can work also with parameters to define function macros: `#define get_max(a, b) a>b?a:b`. This would replace any occurrence of `getmax` followed by two arguments by the replacement expression, but also replacing each argument by its identifier, exactly as you would expect if it was a function.
	- Function macro definitions accept two special operators (`#` and `##`) in the replacement sequence:  
		 - The operator `#`, followed by a parameter name, is replaced by a string literal that contains the argument passed (as if enclosed between double quotes). The operator `##` concatenates two arguments leaving no blank spaces between them.
- **Conditional Inclusions** (`#ifdef`, `#ifndef`, `#if`, `#endif`, `#else`, `#elif`)
	- General Syntax: varies for different directives, usually includes an identifier and/or a condition.
	- These directives allow to include or discard part of the code of a program if a certain condition is met.
	- `#ifdef` allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter what its value is.
	- Similarly, `#ifndef` serves the opposite functionality.
- **Line control** (`#line`)
	- General Syntax: `#line number "filename"`, filename is optional.
	- When we compile a program and some error happens during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a line number, so it is easier to find the code generating the error. The `#line` directive allows us to control both things.
	- Where `number` is the new line number that will be assigned to the next code line. The line numbers of successive lines will be increased one by one from this point on.
- **Error Directive** (`#error`)
	- This directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter: `#error your_msg`
- **Source File Inclusion** (`#include`)
	- General Syntax: `#include <file>` or `#include "file"`
	- When the preprocessor finds an `#include` directive it replaces it by the entire content of the specified header or file.
- **Pragma Directive** (`#pragma`)
	- This directive is used to specify diverse options to the compiler. These options are specific for the platform and the compiler you use.
	- If the compiler does not support a specific argument for `#pragma`, it is ignored and no syntax error is generated.
## OpenMP
OpenMP (“Open Multi-Processing”) is a compiler-side application programming interface (API) for creating code that can run on a system of threads. No external libraries are required in order to parallelize your code. OpenMP is often considered more user friendly with thread safe methods and parallel sections of code that can be set with simple scoping. However, it is limited to the amount of threads available on a node – in other words, it follows a shared memory model. On a node with 64 CPUs, you can use no more than 64 processors.
### Quick Start
This section will introduce parallel programs to an absolute beginner, and also describe how to run such programs.
We begin by writing a simple hello world program, and then parallelize it.

The standard hello world program, we will keep modifying this program.
```c++
/*In a file called parallel_hello_world.cpp*/
#include <stdio.h>
#include <omp.h>

int main(){
	printf("Hello from process: %d\n", omp_get_thread_num());
	return 0;
}
```
Note that `omp_get_thread_num()` obtains the thread id of the process.

Compile and run as follows:
```Bash
g++ parallel_hello_world.cpp -o parallel_hello_world.exe -fopenmp
./parallel_hello_world.exe
```
Output:
```
Hello from process: 0
```

Currently, we have only one thread printing the statement. To parallelize the print statement, we use `pragma` directives, specifically the `#pragma omp parallel {...}` directive to create a section of code that will be run in parallel by multiple threads.
```c++
/*In a file called parallel_hello_world.cpp*/
#include <stdio.h>
#include <omp.h>

int main(){
	#pragma omp parallel
	{
		printf("Hello from process: %d\n", omp_get_thread_num());
	}
	return 0;
}
```

Before we can run this program, we need to set the number of threads we wish to use. The environment variable `OMP_NUM_THREADS` will store this information.
```Bash
export OMP_NUM_THREADS=4
```

Compile and run again, same as before:
```Bash
g++ parallel_hello_world.cpp -o parallel_hello_world.exe -fopenmp
./parallel_hello_world.exe
```
Output:
```
Hello from process: 3
Hello from process: 0
Hello from process: 2
Hello from process: 1
```
On running the executable again:
```
Hello from process: 2
Hello from process: 0
Hello from process: 1
Hello from process: 3
```
Note: We shouldn't worry about the order of processes that printed, the threads will print out at varying times.
### Private vs. Shared Variables
We will now have a look at different variable types in OpenMP and their implementation.

OpenMP allows for two types of variables:
- Private types create a copy of a variable for each process in the parallel system.
- Shared types hold one instance of a variable for all processes to share.

To indicate private or shared memory, declare the variable before the parallel section and annotate the pragma directive as follows:
```c++
#pragma omp shared(shared_var1) private(private_var1, private_var2)
```
Variables that are created and assigned inside of a parallel section of code will be private by default, and variables created outside of parallel sections will be public by default.

Example:
```c++
/*In a file called parallel_hello_world.cpp*/
#include <stdio.h>
#include <omp.h>

int main(){
	int thread_id;
	#pragma omp parallel private(thread_id)
	{
		thread_id = omp_get_thread_num();
		printf("Hello from process: %d\n", thread_id); // print private variable
	}
	return 0;
}
```
Because we want each task to have a unique thread id, using the `private(thread_id)` will create a separate instance of `thread_id` for each task.

The output, except possibly the order of print statements, remains unchanged, as expected:
```
Hello from process: 0
Hello from process: 2
Hello from process: 1
Hello from process: 3
```
### Barrier and Critical Directives
Next we look at how OpenMP manages processes using `barrier` and `critical` directives.

The `barrier` directive stops all processes from proceeding to the next line of code until all processes have reached the barrier, allowing for synchronization of sequences in parallel. On the other hand, the `critical` directive ensures that a line of code is only run by one process at a time to ensure thread safety in the body of code.

We will now use the `barrier` directive to modify the hello world program to print its processes in order.
```c++
#include <stdio.h>
#include <omp.h>

int main(int argc, char** argv){
    int i;
    int thread_id;

    #pragma omp parallel private(thread_id)
    {
        thread_id = omp_get_thread_num();

        for( int i = 0; i < omp_get_max_threads(); i++){
            if(i == omp_get_thread_num()){ // Print only when current loop iteration corresponds to current thread
                printf("Hello from process: %d\n", thread_id);
            }
            #pragma omp barrier
        }
    }
    return 0;
}
```
Compile and run:
```
Hello from process: 0
Hello from process: 1
Hello from process: 2
Hello from process: 3
```
### Work Sharing Directive
Work-sharing directives allow for simple and effective splitting of normally serial tasks into fast parallel sections of code. We will now see how to use the `omp for` directive.

The `omp for` directive divides a normally serial for loop into a parallel task. Syntax: `#pragma omp for {...}`

**As an example,** consider the task of adding all integers between 1 and 1000.
```c++
/*In a file called parallel_running_sum.cpp*/
#include <stdio.h>
#include <omp.h>

int main(){
        int partial_sum, total_sum;
        #pragma omp parallel private(partial_sum) shared(total_sum)
        {
                partial_sum = 0;
                total_sum = 0;

                // Work sharing directive
                #pragma omp for
                for(int i = 1; i <= 1000; i++) {
                        partial_sum += i;
                }

                // The threads must be joined in a one-writer fashion when adding each partial sum to the total_sum.
                // This creates a thread-safe section of the code.
                #pragma omp critical
                {
                        total_sum += partial_sum;
                }
        }
        printf("Total sum from 1 to 1000: %d\n", total_sum);
        return 0;
}
```
Note that, now we must join our threads. To do this we must use a critical directive to create a thread safe section of code. We do this with `#pragma omp critical` directive.

Output:
```
Total sum from 1 to 1000: 500500
```

